LIVE SERVER : 
        HTTP://127.0.01/  =  HTTP://LOCAL HOST

        LOCAL HOST -> 127.0.0.1

        HTTP://127.0.0.1/INDEX.HTML

        PROTOCOL://IP_ADDRESS:PORT/INDEX.HTML

________________________________________________________________________________

j.s is very flexible because it will automatic detect which datatype is prefect for the

JAVASCRIPT :
    
    JAVASCRIPT FEATURES ->
     1. SINGLE THREADED
     2. PROTOTYPE BASED
     3. DYNAMIC
     4. INTERPRETED 
     
    MULTIPARADIGM =>

     1. EVENT DRIVEN -> J.S REACT TO EVENT (MOSTLY USER ACTION LIKE SUBMIT BUTTON)
     2. FUNCTIONAL -> PURE FUNCTION/FUNCTION TREATED AS FIRST CLASS.
     3. OBJECT ORIENTED PROGRAMMING LANGUAGE 
     4. IMPERATIVE
     5. DECLARATION
 
________________________________________________________________________________

JS.VARIABLE => 
     1. DECLARE A VARIABLE
     2. ASSIGN/DEFINE A VARIABLE
     3. USED THAT VARIABLE
     
     1. VAR <VARIABLE_NAME>  {JAVASCRIPT WAS ABLE TO DETECT THE VALUE BY IT NATURE OF THE VALUE THAT'S WHY JAVASCRIPT IS DYNAMIC LANGUAGE}
     2. <VARIABLE NAME> = VALUE;
     3. <VARIABLE NAME>

________________________________________________________________________________

VARIABLE NAME CAN START WITH $,_,AND ALPHABETS AND OTHER NUMBER ARE ALSO ALLOWED ALSO THE ARE.

________________________________________________________________________________

PRIMITIVE DATA TYPE ->
  1. STRING
  2. NUMBER
  3. BOOLEAN
  4. BIGINT
  5. NULL
  6. UNDEFINED 
  7. SYMBOL

  null => is a value that can be ASSIGNed  TYPE OF NULL IS NOT EQUAL TO "NULL" ROTATE IT IS AN "OBJECT" -> IT WAS A BUG THAT GOT INTRODUCED IN J.S INTRODUCED IN JS IN 1990ss

  UNDEFINED -> if we have not assigned any value to variable any value to the variable by the default value is given as undefined and also type of that variable result in "undefined" 
  i.e   VALUE OF DATATYPE BOTH APPEAR TO BE THE SAME.

________________________________________________________________________________

NOT PRIMITIVE DATATYPE :
        1. OBJECT =>
          IS A ENTITY HAVING STATE N BEHAVIOR 

          *=> using object literal->

          VAR OBJECT = {
            KEY: "VALUE"
            KEY: "VALUE"
          }

          VAR PERSON = {
            NAME: "SHARED";
            NAME: 28;
            IS_IIT: FALSE;
            EDUCATION:{
                HIESEC: "PASS";
                B.TECH: "PASS";
            }
          }


          using new KEYword -->
            var person = new object();
            person.name = "SHARED"
            person.age = 25
            person.iition = FALSE
            person.EDUCATION{
            
            }

________________________________________________________________________________

Arrays =>
   declare/DEFINE Arrays

   var x = []; -> declare variable with name "x" and assign it this empty array.
   initialize array with value -> 1,2,3,4.

   eg. var y = [1,1,1,2];

   access value in an array 
   y[0] y[1]


   Que. can we sore different primitive data type in an array?
   var arr  = [1,"rohit",false, 25n];
   ans. yes this happen 

  using new keyword
    var arr = new array ();
    var arr = new array (1,2,3,); -> for declare value in Arrays
    var arr = new array (10); -> declare the length of array.

for (var a = 0; a>arr; a++){
  console.log()
}



________________________________________________________________________________

FUNCTION => 
      syntax -> 
       function fun_name(){
        function reusable code of and set of insertion to ne executed
       }

       eg. function sum(a,b){
        return a+b
       }


________________________________________________________________________________

function sum (a,b){
  var sum = a+b;

  return function dummy (){
    console.log("I am a dummy");
  }
}

arrays are internally store as a object in j.S

________________________________________________________________________________

type of a function (){}
      => function

functin sumof(a,b){
  var sum a+b;

  var dummy = function sharad(){
    console.log("i am a dummy");
  }

  return dummy;
}
var result = sumof(50,30);
console.log(result());

________________________________________________________________________________
J.S operators :- /,+,*,-
 operands ->   2(operands)  +(operator)  3(operands)


operands -> op1 operator op2 (binary operator)

op1 operator -> eg a++ (unary operator)

________________________________________________________________________________
arithmetic = 
      +,-,*,/,%,++,-- .......etc.

        10 + "20"   = 1020
        "10" + "20" = 1020
        10 + true   = 11
        10 + false  = 10
        10 + " "    = 10
        10 + null   = 10
        10 + undefined = NAN

number + string  -> 
  choice1 = convert both into a to number 

  choice2 = convert both in String.

  but one rule remains some -> 
  i.e both type should should be same.

  they gone with option2 -> ie 10 + "20" internally convert to =
   => "10" + "20" -> finally 2string concat (+) -> "1020"

________________________________________________________________________________

number + true 

  number + boolean ->
  but one rule remain same -> i.e bothtype should be same 

  number + boolean ->
   choice 1 = both convert into a boolean = b + B
   choice 2 = both convert into a number = n+N

   "a" + "b" = NAN

________________________________________________________________________________

comparison operators -> 
 <,>,<=,>=,==,===

 20 == 20     = true
 20 == "20"   = true
 20 === 20    = true
 20 === "20"  = false

 == only check the value
 === check the value and also check the value both.

________________________________________________________________________________

short overview of (DOM):- 
                          DOM(Document, object, Model)

  browser = lets represent html Document in the form of object.

  j.s -> DOM ->

  js file    -> Dom -> html

Document.queryselector("h1");

var element = document.queryselector("h1");

element = h1

element.innertext = h1 value

for select id in js file  -> docment.queryselector(#id name);

________________________________________________________________________________

logical operators =>
      (and)&&, ||(or), !(not)

      A && B  
        if a -> false will B Be evaluted 
        ans: no

        if a is true then B is evalated true (yes) 
      var a =  true && "sha" 
      ans: sha

      var a =   true && true
      ans: true 
      
      var a = false && true
       ans: false
  if left operands is truen then return right operands.

  here left operand neet to be type of boolean and if it is not then implicity javascript will convert is to boolean () constructor.

||(or) =>
      is left operands is true then return left return

!(not)=>
 it is used for not.

________________________________________________________________________________

Assigment operators = 

=, +=, -=, *=, /=, %/ **=

________________________________________________________________________________

bitwise operator => 
  not imp for web dev but very imp for dsa.

  var a = 3 +  2 *  5  = 13
  var a = (3+2) * 5    = 25
________________________________________________________________________________

  precedence & associativity:
  each operators in an lang have it own associativity there are 2 type left associative && right associative.

  operators ->
    (=) -> either flow will be from left to right or from right to left.


________________________________________________________________________________

var a = 3 + 2 * 3;
first check operators who have highest precedence then executive them according to their associativity then again repeat return 1
________________________________________________________________________________

scope ->
 local vs global

  local scope->
  if any variable is defined inside function then that varuable can only be accessed inside that function 

  global Scope ->
  if any variable is defined globally them it is accessible to every function.
________________________________________________________________________________

function ->
syntax 1 :
function DECLARATION
function <function name>(){

} 

syntax 2 -> 
function expression


2.1 -> named function
var <variable_name> = function<function_name>(){
.......
}

2.2 ->
anonymous function

var <variable_name> = function(){
......
......
........
Runtime error
.....
......
........
}


 syntax 3->
Ife (immediately invoked function expression)


 function my(){
  var sum = 2+3;
  return sum
 }
 my();

requiraments->
 -> i want to be function be execute immediately but also it should execute only once 


syntax: 
{
  function (){
    ......
  }
}();


4. Arrow function (Es6) - tbd  (to be discussed)

 
________________________________________________________________________________

How j.s works?
j.s is SINGLE THREADED , it is also synchromous ->

that means only 1 statement can execute at a time.

Execution context :
Whenever js script is INTERPRETED, execution is created context is created for each function invocation.

by default there is global execution context created Whenever our code is executed. 

Execution context is made of 2 phases :
  1. memory 
  2. execution

  1. Memory creation :
  Memory is allocated to each object and function (internally function are also object ) 

  eg:
  function sum(){
    var result = 10 + 20;
    console.log(result);
    return result;
  }

  var name = "sharad";

  here, sum and name needs to be allocated memory.

  once memory is allocated js will assign value to these.

  for variable default value is undefined.

  for function default value is -> whole funciton body is copy/pasted.

  2. execution phases: 
  

________________________________________________________________________________

by value vs  by reference :
in js object & arays (basically object only) are reference while peimitive (number, boolean,String etc ) are treated as value

int arr []

________________________________________________________________________________
hoisting ->
  ability to access variable and function even before   declaration internally there is no magic this is how js execution context work and  due to which this kind of phenomena.

________________________________________________________________________________

ES6 variable construct : (es6 ~ es2015  ~ feature intruduced in 2015 in javascript)
{  let,   const  }


both keyword are used for declaration.

let -> 
    1.   var title = "moksh"

       v/S
    2.   let title = "moksh"

  both are different with respect to scope 
  
  var is function scoped and let let is block.

  function scope: 
            any thing defined inside function key word will be visible in that function only.


  Block Scoped =>
            any thing defined inside block i.e opening block { and closing block } it will be visible inside these bracket.
            it will inside in the opening and closing bracket.



const -> it BEHAVIOR same as let only diff being it cannot be reassigned.

 
________________________________________________________________________________

var =>  declare with var hoisted it can be accessed before declaration.

let,const => variable with var are not hoisted but in reality js work the same 
(i.e execution context memory allocation please happen for these variables also 
that mean memory is allocated to these variable also that mean memory is 
allocated to these variable to but they still can not be accessed due to temporary zone  )

________________________________________________________________________________
 loops =>
      1. while loop 
      2. do while
      3. for
      4. switch case 
      5. if else 
      6. else.if....if..else
      7. break continue 

________________________________________________________________________________

parse Int /  Parse Float =>
                    parse int ("saved25 ) -> NAN

                    i.e only when digit are present in the being it is able to extract. 

    parse Float ->
              same rules as parsing change to float.

________________________________________________________________________________
 object's :->
            var obj = {
              key: value
            }

            or 

            const obj ={
              KEY: value
            }

            or

            let obj ={
              key:value
            }

            here key can be String or symbol where as value can be anything also key needs to be unique also.

            let obj ={
              title : "moksh",
              age : 25,
              }


            how to access => 
            1. Dot notation 
            2. bracket notation

            obj["title" ]


            let object ={
              title : "moksh",
              age : 28;
              "this is age" : "lol"
            }

for access this is age we use bracket notation

obj["this is age"]

bracket preferd/only option the 

this is space between keyword.

when we want access some value of object with dynamic key'S

--------
obj delete ['age']

delete ant property of object 
delete<object_name> [keyword]

________________________________________________________________________________

{} === {}

________________________________________________________________________________

shorthand: 
      let title = "sharad";

        let obj ={
          title: title,

        }

        or

        let title = "shara";

        let obj ={
          title
        }

        or

        let person = {
          name: sharad,
          age: 28,
        }

        
        let person = {
          name: sharad,
          age: 28,
        }

        
        let person = {
          name: sharad,
          age: 28,
        }
j.s is not close base lan

function person (name, age){
  
}

let person1 = ("sharad", 28);
------------

function person (name, age){
  this.name = name;
  this.age = age;
}

let person1 = new person("sharad", 28);

here new -> create new object and assign that newly related object to this variable and it return newly created object.


this -> it is act as a place holder variable name for this newly created  object.

new => 
      created object -> {}
      point "this" to newly created object.

      this ={};

      return newly created object.

    whenever inside the function we want to fill certain details in the newly 
    created object we can use "this" keyword for that. 

________________________________________________________________________________
"this" is nothing it is the empty object
________________________________________________________________________________

making object using constructor 
function person(name, age){
  this.name = name;
  this.age = age;
}

let person1 = new person ("sharad", 28);
console.log(person1)

this keyword point to some entity on js(generally it will point window object )creating object via function constructor this  point to newly created object.

________________________________________________________________________________

SYMBOL: =>
            primitive type 
            used to generate new value 

            Syntax: 
                    symbol(<name_declare);

even if name description is same then also symbol constructor will return different/ unique symbol VALUE
________________________________________________________________________________

symbol ("sharad" ) -> return symbol value or symbol (which is always unique)

usecase:
     primarly sued as a key of object since key always be unique hence creating keys of object with symbol instead of String will help avoid key duplication.

Note:+++++++++++
    in order to avoid uniqueness we can use symbol for()

--------------------------------------------------------
eg. 
    let symbol = symbol.for("title);
    let symbol2 = symbol.for("title");

    symbol === symbol2 
    => true

i.e if description is same then symbol value should also be the same.


object:
  
  In keyword:
      <keyname> in <object_name>

  has own property keyword:
      <keyname>.hasOwnProperty<object_name>

________________________________________________________________________________

Methods: 


      let obj = {
        title: "sharad",
        age: 28,
        
        showtitle : function(){
          console.log("hey i am a function");
        }
      }



getters & setters :
          any method inside object can be termed as a getter or setter via keyword "get" and "set"

while calling getters/setters methods, () should not be used.

let person ={
  title: "sharad",

  get gettitle(){
    //can do anything bu generally used to fetch object properties
    return this.title;
  }

  set settitle(name){
    this.title = name;
  }
}
person.settitle = "ankit";
________________________________________________________________________________

loops :
        1. for

        2. while

        3. do.while


   1.    
   (i)  for...in ->

            let obj ={
              title: "sharad",
              age: 28;
              isNew: false 

            }
            for(let element in obj){
              console.log(element);
            }



      it is trying to itterate over obj object and on each iteration there is a variable called element which is filled with keyname.

________________________________________________________________________________

Dom (document object model):
interface/bridge between js and html/css 

whole document (ie html page ) represent in the form of js object

object is available globally and named as "document" it is a part of global window object also (window.document).

now,
 any js object consists of properties and method.

 under document object we will use certaing methods to interact with out html page. 

1. getElementById -> input is Id name -> output is html element is found and null if id will not found by the js selector.

2. getElementByClass -> input is Class_name -> output is htmlCollectionOf<element>  (arrays of element but not completely true)

3. getElementByTAgName -> input is tag_name -> output is -> htmlCollectionOf<element>   (arrays of element but not completely true)


4. queryselector -> input is css_selector -> output is -> Element or null

not : query selector always return signle element if more than one element matchesm, then element tag comes first will be returned by this method (top to bottom manner)

5. queryselectorAll -> input is css_selector -> output is nodelistof<element> or null


all the above element of document are for ->
to get hold of particular html element.
this is similar to css selector where we used to catch hold of particular html element.

eg: Id selector(#ID), class selector(.class_name);

________________________________________________________________________________

split is very imp interview que
________________________________________________________________________________

how to add and create html element via js add to html page?

document.createElement("div");
 
 const element = document.createElement("div");
 element.innertext = "h1 Created via js";


 how to attach to html page?

 document.body.appendChild(element);

________________________________________________________________________________

script tag ->
 
        defer vs async

defer suits in situations -> where js file is intereacting with DOM
async suits in situations -> where js file is intereacting with with Dom

initially
In Defer there is a guarantee of order of execution whereas in async there is
no guarantee

________________________________________________________________________________

transform: "translate(x,x) Scale() rotate()"
________________________________________________________________________________

note:
if value undefined given, then it will treated as string "undefined"
if value null given then, it will be treated as a empty value
if value "" given  then it will treated as a "" value

________________________________________________________________________________

function beautifuname(name, prefix = "lord", decorate){
    if(decorate){
        return decorate(name)
    }
    return `${prefix } $ {name}`
}

const v1 = beautifuname("sharad");
const  v2 =  beautifuname("sharad", "newton -")

const decorfunc = function(name){
    return  ` $ {name} name is going to enjoy week`
}

const v3 = beautifuname("sharad", "" , decorfunc);

here line no. 807 we are passing function and we are allowed to do so in javascript since functions are treated as first class citizens in js i.e function should be treated as a normal value/variable like boolean object array number etc. that mean function can be passed as input to any other function also it can be returned i.e can be returned i.e function can return function here decorfunc can be called as "cal back function"
why? because decorfunc is not called directly rather it is being called by other function

Note: in above usecase, actual power of callback funcation is not visible it is primarly used for async

console.log(v1)// lord sharad
console.log(v2) // newton - sharand
console.log(v3) // sharad

________________________________________________________________________________

document.querySelector(".grandparent").addEventListener("click", function(){
    console.log("Grandparent clicked");
 
}, true);
document.querySelector(".parent").addEventListener("click", function(){
        console.log("Parent clicked");  
},  true)
document.querySelector(".box2").addEventListener("click", function(){
    console.log("Box 2 clicked"); 
}, true)
document.querySelector(".box1").addEventListener("click", function(){
console.log("Box 1 clicked"); 
}, true);

   whenever child is cliked (OR basically any event is fired ),
   then only callback function of child div should be ivoked?

   or

   all the html element (who are in hiererchy w.r.t child div) ->
   for these html elements onclick callbackj function should be run (only for when callback functoin is registered on them via addEventListener ).

   second approach got finalized.
   Now  quetion was ->
   Now to implement the flow?

   i.r->
   Whether function of child should be called first then  
   callback function of parent should be called,
   callback function of grand parent should be called 

   or (oppsite flow)

  Whether function of child should be called first, then,  
   callback function of parent should be called,
   callback function of grand parent should be called 

  -->

  it was decided that lets keep both the flows.
  first  flow was named as -> BUBLE
  second flow was named as -> CAPTURE

  Event Bubble -> 
  Bubble means it goes up (i.e from where it happend till last html element)

  Event Capture ->
  capture meant it goes down (i.r from first htm element w.r.t hirerachy till the point where it happened )

  by default Event Bubble technique is applied
   In order to change the stragety to capture ->
   we use supply third argument to add event listner methnod methnod as true

   Now we want to conclude How events are actually traversing across DOM:
   
   we need to remember that flow always goes form top to targer first.
   then, it travarses back from target to Top.

   i.e each DOM element is given 2 chances to execute their callback funciton either during capture phases or During bubble please.
   
  in case we want to stop propgation of events we can use stopProgpogation() methnod of event object.


thumb rule is  if possible to keep event listener callback to Minimum.


________________________________________________________________________________
 Call, bind, apply

if we want to change CONTEXT of THIS variable inside methods we  can do that with the help of method called - call(), apply(), Bind().

let obj = {
  name: "sharad",
  age: 28,
  printname function(){
    console.log(obj.name);
  }
}

here this points to obj object
Now we want "this" to point towards some other object.

eg.
let obj2 = {
  name: "trikajh"

} 

Basically we want "this" inside printname method of obj2 to point to "obj2" rather than "obj". 

obj.pritname() -> this will point to obj.
but i want to perform some magic that it should be start pointing to obj2

basically we want to change CONTEXT of this i.e we want to change - where this is pointing to ?

to do that there are 3 type

call ->
<function>.call(<variable_that_you_want_this_to_point_towards>, <input1> , <input2>)


apply ->
<function>.apply(<variable_that_you_want_this_to_point_towards>[<input1>, input2])


in case of apply second arguments is array form

bind ->
  bind is also changes context of this but its different from call and apply in the sense that incase of bind function is not good executed immediately.

  bind method -> returns a function with context of "this"

    <function>.bind(<variable_that_you_want_this_to_point_towards>)

    bind method returns new function with new context of "this"
    i.e we can call the function at a later stage whenever it is required.


 1. by the help of call method:
 
         obj.printname.call(obj);



 2. by the help of apply() method 
 
          obj.printname.call(obj);

  2. by the help of  bind() method
           obj.printname.bind(obj);

________________________________________________________________________________

object -> creation constructor function 
object literal -> " "
new object{}

object.create; 

if you want to inherit some properties if existing object while creating new object.

var vegetables ={
  status: healthy

}

now lets create new type of vegetables called - brocoli.
since brocolli in type of vegetables then means should be inherit all the properties of vegetables ...............

this is some waht trending towards inheritence i.e inhiriting properties of parent.

var brocoli = new object(); X

var brocoli = object.create(vegettabls)

 as soon as we did that brocali got created bu there is no properly called "status" directly attached to brocolli.
 then there is one random object {[prototype]}; object inside which "status"
 property reside.

 Now whenever we use dot operator to referencs some property inside object.
 How javascript behaves?
 first js will check or look put for that property at top most level.
 if not Found -> it continues it's search in there {[prototype]};

 By default whenever we create any object in javascript.... this newly created object inherits some of the properties and methods and object.

var obj  ={
  name: sharad,
  age: 28;

}

object.Keys(obj) -> {name, age}
object.values(obj) -> {sharad, 28}
object.entries(obj) -> [[name : sharad]]


 for in loops :

 emurable properties of object: 

 any object in js that has properties 
 here we can attach some behaviours(writabble, emmurable) to these properties
 emmurable can be set to true or false on each properties of an object.

var person ={
  name: "saharad",
  age: 28,
}

now we want to this object "person" but whenever anyone tries to itereate over this object.....then..... property should not be visible during iteration.

whenever we create properties of an object via literals then enumrable flag is automatically set to TRUE. i.e these properties can be itereated over loops like for..in and also present present in object.keys

but if your want explicitly change enumrable flag to false for some property of an object.
it can be done with the help of ->
object.defineProperty

syntax:
  object.definedProperty(<object_WHERE_PROPERTY_WERE_DEFINE>, <KEY_NAME>, {
    //descripter i.e 3rd arg is an object that describes the value along with enumrable flag
    <value>: <whatever_value_you_Want_to_assign>
    <enumrable>: <boolean> if set to false => this property won't be presented during intereation of object and also, not presented during object.keys
  })

to check wheather property is enumrable or not -->
<object_name>.propertyIsEnumrable(<property_name>)

to check wheather property is of own or inherites.


for..in loop ->

iterated over enumrable String properties only.
________________________________________________________________________________

I'a a js library creater and i gave 1 object to outside world to use in their codebase.

now lets assime object has big if any consumer itereate iver it then unnecceary he will have to inhrit over properties which are not meant to be iterated upon.

var person ={
  name: "",
  age: "",
  printMyName: function (){
    //
  
  }

}

now from we undertand that itereating over anme, age might make sense for some programing logic... why to waste  itereation over printName?   

________________________________________________________________________________

prototype:
  every object in javascript contains 1 property popuraly known as "prototype".
   "prototype" property itself is object.

   since "prototype property is available on every object in js and in this "prototype" property , (which is an object itself() contains certain properties/methodswhich can be used directly VIA dot operator) 

    By default whenever we create any object in javascript.... this newly created object inherits some of the properties and methods and object.

________________________________________________________________________________

now "prototype" propeerty of any object is referred by a key Called "__proto__" --> here generally whenever "_" is prefixed on any property name, it signifies that it is a internal property and it should Not be used.

var obj ={ 
  Key: VALUE,
  [{PROTOTYPE}]: object
}

[[prototype]] -> __proto__

Now, whenever we are accessing obj.__proto__ ->
we are getting object is retuen.
this object is nothing but value of prototype OBJECT.

 

________________________________________________________________________________
let arr = [1,2,3];
array is nothing but it is an object.
every array has prototype
________________________________________________________________________________

inheritence:
  acquring properties / behiovour from some other entitiy.
  In Javascript, it imlies acquring properties/methid of some object.

  var obj ={
    name: "sharad",
  }

  obj need to have these methods by default : 

  1. tostring
  2. valueof

  Now in order to have these methods bydefault to every object created in javascript, we make use of prototype inheritence.

  In class based lang.. inheritence works different.
  ie. 
  class parenmt{
    // properties

    //methods
  }

  calss child ectends parent {
    //inplement or overrieds
  }

  Now in js which is a "object based " Inheritence is done via prototype. i.e all the properties/methods whcich are added to the  "prototype" property of the object.

  Now does prototype inheritence inplemented?
  
  1. Wrong/discouraged way:

    directly <changing __proto__ property of object.
    let ovj2 ={
      name: shra,
    }
let ovj1 ={
      name: shra3,
    }

    obj1.__proto__ = obj2;

  2. Right way:

   using Object.create

    let ovj2 ={
      name: shra,
    }
    let ovj1 ={
      name: shra3,
    }

    let obj2 = Object.create(obj1)
    obj.title = "sharad"

  eg. 
  lets create parent object called "person" and implement certain methods specific to a person 
  
  let person ={
    canWalk: funcation(){
      console.log("person can walk")
    } 
    canTalk: fucntion(){
      console.log("person can talk");
    }  
  }

  Now lets create object representing specific person called "sharad". Now since sharad is "type" of person so "sharad" would like to inherit properties/methods of person.

  let personSharad = objec.create(person)
  //above line create an empty object with "prototype" property of this empty object set to/point to person object.
 

  using constructor function


    let person = function(name){
      this.title = name;
    canWalk: funcation(){
      console.log("person can walk")
    } 
    canTalk: fucntion(){
      console.log("person can talk");
    }  
  }

const p1 = new person("sharad");
here every thing we wanted to achieve is done 
also it look like there no need of inheritence
but there is issue here.

Whenever object gets created via "new" Keyword....
all the properties inside object gets memort alloacted.
here properties can be of type - number, boolean, object, function....etc
Common Behaviours is like canTAlk, canWalk are given memory on each object Instantiation.


to mitigate that we can make use of "prototype" peroperty of function constructor 
i.e all the functionality/methods/properties which are common to every instance can be put insitde "prototype" property.

example:

person.prototype.canwalk = fucntion(){
  console.log("person can walk")
}

person.prototype.canTalk = funciton(){
  console.log("person can talk");
}

conclusion :
  object.create(<whatever_you__your_want_new_object_prototype_to_point
>)

  <funciton_constructor_name>.prototype.<whatever_you__your_want_new_object_prototype_to_point


confusing creating terms :

__proto__
prototype
[[PROTOTYPE]]

confusing creating statement :

  object.prototype = obj.__proto__

prototype chain ->
every object have one peroeprty called "prototype".
this property is itself an object, thereby having peroperty called "prototype" this goes on till the value of "PROTOTYPE" IS NULL

THIS CAHIN OF PROTOTYPE IS NOTHING BUT "PROTOTYPE" CHAIN"
________________________________________________________________________________

fucntion prototype: 
 every function cunstructor in js have one property called <prototype>
 
 const obj = new obj();
 here object is constructor function. 
 
________________________________________________________________________________

Javascript String :
    string mean anything is written in the double quote and single quote

in js string can act as primitive as well as object. is string is created with largely convention is if string is created with literals it act as primitive.
if created with new String () -> hen it acts as object.(non-primitive).

whenever we use dot operator string primitive we are still able to access prperties/methods -> because in javascript converion happens due to with primitive convertred to String object.

property :

1. length poperty :
    in string we have length property available to us which counts number of characters in a string and return that number......4

    Note this is not exactly true.

Methods :






 1. retriving specific character via index :
      String[index]
 2. Test if string contains substring or not :
      let str1 = "hello wrold"; 
      let str2 = "hello";

      str1.include[str2]
  <pearent_string>.includes(<substring_you_want_to_search);
      this method return boolean value.

 
 Method chaining :

    let str = "hello world wolr is so aswome";
    str.tolowercase().replaceAll("world", "sharad")

    one way to weite it as :
    let str 2 = str1.tolowercase();
    let str3 = str2.replaceAll("world", "sharad");

    bu this can be done in a shortner syntax without declaring to many variables.

    str1.tolowercase().replaceAll("world", "sharad");


converion of String to array :

LET Str1 = "hello world";
we need to convert to array ["hello", "world"]

split() :
it takes input 1 regEx or matching expression and based on it splits characters into array


________________________________________________________________________________

ARRAYS: 

  const arr = new arr();
  const arr = [1,2,3,4,5,6];

convert array to String:

join(<seperator>) -> return String 

search index of an element of aray:
indexof(<array_element_to_be_seached>)
if found return index of that element otherwise -1

check whether element exist or not:

.includes(ARRAY_ELEMENT_TO_BE_SEARCHED) -> return boolean 


add element to the end of array :

.push(<ARRAY_ELEMENT_TO_BE_addeded>)

add element to the begning of the array:

.unshift(<ARRAY_ELEMENT_TO_BE_added_in_the_begning>)

remove element from the end of array :

.pop() -> returns removed element

remove element form the start:

.shift() -> returns removed element

________________________________________________________________________________

DEleting elements of an array and also modify the existing array:
  .splice(start, delete_count, add_item1, add_item2, add_item3.....)
  return the all elements 
  simplext form:

  .splice(start_index);

________________________________________________________________________________


higher order function?

const obc = function(def){
  def();
};

here what is abc and what is def?

here abc is Higher order function i.e if a function acepts any function as input or return function then that function come termed as higher order function 
 def is callback function -> function that might be called immediately or any function which is called inside a function

________________________________________________________________________________

iterate:
   foreach loop:

   invokes a callback for every element in array.

   const arr = [10,20,30,40,50]

   arr.forEach(<CAllback_function>);
   where (<callback_function> ) will be executed for every element in an array.
   this <Callback_function> is supplied with certain inputs like-current_element of array index array.

________________________________________________________________________________

sorting array:

  const arr = ["grayfindor", "newtron", "placment", "guarantee"];

  short array based on the alphabets:

    arr.sort(); -> return the sorted array and the sources on which it was used i.e its mean it mutate the original array.

    it works well on array of strings since internally ascii  are compared 

    Note: 
    in case to avoid either capitalization issues either convert to lowecase or uppercase.

    but it does no well work in the case of number. 
    eg. const arr = [22,222,222,999];

    to fix this inplimentation of compare function i.e sort method callbacks function as argument that can help sor elements of an array.

    arr.sort(<CAllbacl_function>)

  (callback_function) gets 2 element  as  argument these elements are elements of array only.
  
  return value :
    <callback_function> needs to return :- 

    1. negative: if it is negative then a is sorted before B
    2. positive


    a-b -> here represent first value and b -> second value
    if first_value - second_value is negative -> it means first value was smaller 

  fucntion compare(a,b){
    //here a and b are two elements of arrat 
    return a-b;
  }


code Trace:
 eg. const arr = [22,222,222,999];
  fucntion compare(a,b){
    //here a and b are two elements of arrat 
    return a-b;
  }

  1st iteration 

  compare -> 22, 222

  22 - 222 -> negative
  means _____________ first value was smaller -> donot swap...

  2nd iteration

  compare -> 222,999
  222-999 -> positive
  mEANS  _____________ first value was larger -> swap...
  22,222,999

  ->
  22,222,999

   


________________________________________________________________________________


merge array:

  concat() method

________________________________________________________________________________

filter, map, reduce :
  higher order functions 
  callbacks function
  
  here filter map reduce are higher order functions. all 3 of them take callback function as input like all the methods these methods are also chainable.

  filter:
    filter method as the name suggest in used to filter elements of an array based on some condition (that means based on boolean value).

    const ar = [10,20,40,5000,1000];

    filter out/remove all the elemnts whose value is grater than 100 from above array.
  input - [10,20,40,5000,1000]
  output - [10,20,40]


arr.filter(callback_function);4

here callback_function needs to return true or false....
based on that element will be added or removed.

return type:
  filter() method new array of elements (which satisfy the condition written  inside callback_function)

________________________________________________________________________________

map: 
  it is used to alter/change elements of an array.
eg:

  const arr = [10,20,30];

  reqirement:
    multiply every element by 
 and store it in a new array.

 const arr = [10,20,30,40,50,200,300,400,500]

 requiraments:
  filter array only having elements having less than 100 and after that multiply remaining element by 3...
  finally return the new array.
     
     arr.filter(function(elem){
      return elem<100
     }).map(function(element){
      return element*3
     }).sort(function(a,b){
      return b-a;
     })


reduce :
  it is used whenever we want to iterate over array bu need to conslude in a single  value.

  eg:
  const arr [20,30,40,50]

  req: sum of all elements?


syntax:
  arr.reduce(<callback>, <initial_value>);
  here <calback> gets 2 important inputs these are different form callbacks of foreach map, filter,
  here 1st input is generally termed as accumlator.
  2nd input is termed as current_value (is the value we get on each iteration i.r it is same as 1st arguments of callbacks of filter, map)

  
  if <initial_value> is not set then it assign first element of array into accumlator and starts looping from 1st index if array and current_value is assingned as arr(1)

_____________

const  stt = [1,2,3,4,5,6,7,8,9]

requiraments:
we need to check whether all the elements of array. are less than 60 or not.

so bsically we need a bullean output.

.every() method can use here since we need to check the element of array.

_____________


requiraments:
we need to check whether some the elements of array. are less than 60 or not.
const  stt = [1,2,3,4,5,6,7,8,9]

.some() ,ethod can be used here since we need to check some of the element of array.

________________________________________________________________________________
+
finding element in an array:
find() method can be used pass callback function to find() method and it will return only one element as soon as condition inside callback is met 

.find() 

________________________________________________________________________________


Scope:
 define wheather any variable is accesible or not.

 function abc(){
  var dummy;
 }
 console.log(dummy) 

 -> i will not be able to find dummy variable outside function abc since scope or visiblity of dummy variable in funcation scoped i.e it is only available inside abc function

 _______________________________________________________________________________

 execution context and lexical enviorment :

 whenever function vall/invocation happens, execution context is created and it is pushed to a stack.

 and then once function is executed then exection context is removed for the stack.

now a along with creation of execution context there is one more thing that gets created at the same time and we call it lexical envirorment.


var title = "sharad"

fucntion printmyage(){
  var age = 28;
  console.log(title)
  printmyage(){
    console.log(age);
  }
}

_______________________________________________________________________________





_______________________________________________________________________

Onject oriented JAvascript:  
(OOJS)

1. procedural paradigm
2. object oriented paradigm

these paradigmms enforce way of writing code. 

procedural: 
here object oriented paradigms got intoduced with the motive of 
making code look less complex and meaningfull
to chieve these things we have 4 pillars :
1. encapulation
2. abstraction
3. inheritence 
4. polymorhism

1. encapsulation :
        combining data and methods/function that act on the data in a single unit 
        purpose ? reduce complexity and makes things more redable/comprehend.

2. abstraction : 
    
  showing only essential part and hide actual implementation 
  pusporse? to make simple interfaces.

3. inheritence :

          aquring the propeerty or behaviours form some entitiy.
          


4. polymorhism :
        
          poly - multiple
          morphism - forms

one name -- many form.....

how to implement in javascript?

function furit(){
  
}
 furit.prototype.displayname = function(){
    console.log("hey i am fruit")
   }

--lets create subclass/child class--
function Apple(){}
apple.prototype = Object.create(furit.prototype);

req: 
now any instance created via apple constructor function and whenever we call
displayname() method...then..it should print "he i am apple" insted of "hey i am furit"

ie. apple (subclass or entitiy which inheirts parent entitiy called furit )
should override this method displayname();  

apple.prototype.displayname = function(){
  console.log("hey i am apple")
}

folowing statements is also the part of polymorhinst:-
console.log(1+1); // 1
console.log(1+"1"); // 11

_______________________________________________________________________

Destructuring :
        Array:
    const arr = ["sharad", "akashay", "alasj"]

    requirements:
    want to get firstelement and secondelement of arr.

    const firstelement = arr[1]
    const secondelement = arrp[2]

    same thing can be ashieved with a different way/syntax :

    const [firstelement,secondelement ] = arr;

  above line depicts that ->

  here [] brackedts are used becuse we are working with array.
  take first element of array and assign it to a const variable called firstelement 
  take secondelement of arr and assign it to a const variable called secondelement

  now let say we want third element of arr to be stored in a variable called "third".
  what will be the change require in above syntax?

  Object :
  const perosn = {
    name: "sharad",
    age: 25,
    work: "instructor"
  }

  const firstelement = person.name()
  const secondelement = person.age()

  same thing can be achieve wit a different way/syntax :
            
            const { name, age} = person
        
        initialize a const variable called "name" and then.
        search for a proerty called "name" inside person object and return its value
        this new variable of "name" 

        now 
        there are some difference w.r.t destruct array vs destruct object:
        1. [] vs {}
        2. here during array destruct variable name can be anything and alwaus order is
         maintained i.e first variable will always get arr[0]...second
         variable will always get value present in arr[1]...so on....

         but during object destruct...variable names need to be same as name of the key i0nside the object.
         this might appear as a flow of we want to create variable with a different name(i.e name than is  present inside object's keys )

         Syntax :
          const {object_Key:Any_Variable}  = person.

          important usecase W.R.T function :
              lets say i write a function that prints first NAme.

             function printFirstNAme(Firstname){
                console.log(` hello my name is ${Firstname}`)
              }

              Now, anyone can send full object.. but our method will only  

_______________________________________________________________________________

Rest Operator(...)  :
  combine multiple elements  into one.

  usecase :
    const arr = ["sharad", "akashy", "akash", "paul"]
          
      i want first 2 elem of arr in variable called "firstelement" and "secondelement" and the rest of
       the remaining elements should be saved inside  a variables called "leftOver"...This "leftOver" variable should be ARRAY.  

  rest operator also works with objects. 

    usecase :
      design the function that can accept ubtimmited arguments as inputs.

      Soln:
        function fn(...variablename){
          //here variable name will club all the indput into array and the then 
          that array can be used for all the logical works to be done inside function

        }
_______________________________________________________________________

spread Operatror(...) :
    spread is opsite of Rest. Although, ... is reperesented for spread operator also
    one unit (iterable - array,object) is spread into multiple units. 

        const humman = {
        feelings:true,
      }
    undefined
    const person = {
        name: "sharad",
        age: 28,
        ...humman
      }
    undefined
    person{
      name: 'sharad',
      age: 28,
      feelings: true
      }


_______________________________________________________________________

short curcuit evaluation :
  
  function hello(){
    console.log("hello wrold")
  };

  hello()

  Now, what will be the output of the following code?

  False && hello();

_______________________________________________________________________

optional chaining :

    const person = {
      name: "sharad",

    }

    person.xyz ->  UNDEFINED
    person.xyz,querty -> this will be throw the proper erro

  
    solution :
      person.xyz?.querty -> UNDEFINED
      
      if we font use "?" in this then our ui will be the crashed.

_______________________________________________________________________

null coalescing:
    (??)

    const age = null ?? 28; 
      
    it operats on 2 operands...here if operand on the left side to null.UNDEFINED
     then it return value on the right side (i.e 28) ...but if left side is not Null/UNDEFINED then value on the left side is return  
_______________________________________________________________________ 

  Factory Function :
    const car1 = {
      model: "creta",
      year: 2022,
      color: 'white',
      varient: "SX"
      carMove: function(){
        console.log("CAr is moving............");
      }
    }
  const car2 = {
          model: "i20",
      year: 2022,
      color: 'black',
      varient: "SX"
      carMove: function(){
        console.log("CAr is moving............");
      }
  }

  function Car(model,year,color,varient){ 
    this.model = model;
    this.year = year;
    this.color = color;
  } 

  new CAr("","","")


  till Now we have studied making new ibject via constructor function with the help 
  of new keyword.

  there is one more way of creating object eithout new keyword with the help of 
  simple function.

  function Car(model,year,color,varient){
    return {
      model,
      year,
      color,
      varient,
      carmove: function(){
        console.log("CAr is moving.........");
      }
    }
  }

  const car1 = car("creata", 2022, "white", "sx");

_______________________________________________________________________

cloning An object :
  let obj1 = {age:28}
  let obj2 = {...obj1}

  but here it appears that clone is secessfull...
  i.e deep clone is performed but in reality it is still swallow clone.
  but it only till first level in hierarchy.

  i.e if there are any nested objects inside a object these nested objects are
   swallow copied...,

   using object.assing() : 

      Object.assign(<TARGET_OBJECT>, <SOURSE>........<SOURSE2>,......<SOURSE>)
      takes all the properties present in all <sources> an copy them inside 
      <TARGET_OBJECT> and then  returns <TARGET_OBJECT>;
     
      let obj = {
          age: 28
      }  

      let obj2 = Object.assign({},obj);

      
  but here it appears that clone is secessfull...
  i.e deep clone is performed but in reality it is still swallow clone.
  but it only till first level in hierarchy.
  i.e if there are any nested objects inside a object these nested objects are
   swallow copied...,


  JSON.parse(JSON.stringify()) -> this will do deep cloning but it is no the recomeded
  method to do it since it is not performant and highly discouraged.

_______________________________________________________________________

Inheritance :
    How to implement inheritence?
 
    USecase :
    PArent class called PERSON which needs to be initilized with certain propeties like name and age.

    there is child class called employee (which is a PERSON to!) and it needs to be
    initilized with properties like name, age, and employmenttype.
      
    How can we model it in javascript ?

      Refer function_class.js
_______________________________________________________________________


function arrguments :

  Build an object passed to every function (whenever it is invoked)
  it is an object which looks like an aray.
  i.e arr[0], arr[1] --> index can be used to refer data.
  It has .lenght property also.
  but it is not exctly array...i.e we cannot use array methods like push, pop, etc...



  function sum(A,B){
    console.log(arguments[0]);
    console.log(arguments[1]);
    return A+B;
  }

    function sum(A,B){
    console.log(arguments[0]);
    console.log(arguments[1]);
    return arguments[0] + arguments[1];
  }

Write a function to sum n elements.

sum(1,56,5,5,5,5)
sum(542,867)

one approach -> 

  use argumengts object 
  iterate over and add these values.

  function sum(){
    let result = 0;
    let arr = [...arguments]
   // iterate ofer arr and each iteration add values to result variable
   for(let i =0;i<arr.length; i++){
    result = result+arr[i];
   }
  }

_______________________________________________________________________

Arrow function (ES6) :

Till now we are used to writing these syntaxes like function:



  const func = function (){} // function expression
  function func = (){} // function declaration

  Now there is one more syntax for function --> 

Type one :

  function sum(A,B){
    return a+b;
  }

Type 2 :
  const sum = function(a,b){
    return a+b
  }

Type 3 :
  const sum = (A,b) => {
      return a+b
  }

  observations
  1. function keyword was removed 
  2. => got introduced before { Brackets

  Shorthand : 
    if only 1 argument is required then no need of brackets  
    eg: 
    const addBy2 = A => {
      return a+2;
    }

if only 1 staments/expression is to be executed then {} and return keyword is also 
not required

  const addby2 = a => a+2;


when to use arrow function vs when not to use ? 
  in incase of normal functions value of this is decided by who is calling that 
  function (i.e binding, is created);


  But in case of arrow functions no binding of this is created...
  rather it will THIS of nearest element... (must of the time in interview , it will be window)


  When not use Arrow function:
    1. if inside these function THIS keyword us used.
    2. if we want to create constructor functions, arrow function cannot be used.
    3. constructors methods/functions cannot be arrow function.
    4. arrow function do not have arguments object.
    5. cannot use bind, call,apply -> sinzce new binding of this cannot be created by arrow functions.
    6. super keyword is not present in arrow functions.


_______________________________________________________________________

try/catch :
  
  whenever there is a error in js code then js throw error and all the code written after that line will not run.

  when we do not handler errors by ourself them has to handle it but browsere way of handling errors is not too great (Sinace it stops all execution )
    
    Therefore there is need for developers to handle errors by themself.

    try{
      // put all the code where error is anticipated insite try block 
    }

    Now as soon as we place try block we get a error saying :
    uncaught syntaxerror: missing catch or finally after try 

    basicaly it means if try keyword us used them Either catch or 
     finally keyword needs to be used...
     (note: BOTH (catch and finally) cn also be used togearther with try )

     catch block :
     only runs/executes when some error happens inside its try block 
      any error that happens inside TRY block will be CTCHED by this cathch block.

      if error happends inside try block, then, code execution shift to its corresponding catch block.
      also after catch block finish running...code execution does not go back to try block
      ((from where it leftOver)...rather it starts execution lines written after catch block.)

  catch block ->  gets 1 arguments (error object) by default...
    error object ->
    1. name keys -> name of the error 
    2. message keys -> message w.r.t error
    3. stack key -> stacktrace i.e from where/which line this error came from

  Finally block :
      
      this block is executed whenever there is some error inside try block...

      whenever any ERROR occurs inside try block, then, there are following paransthises of code execitions/flow :

  1. either it will jump to catch block(if implemented )
  2. or it will jump to catch block (if implemented ) and agter executing catch 
    block...it will start executing its finally block (if implemented )
  3. or if cathch block is not implemented but finally block is implemented...
    then it will execute finally block.

eg.:
  talk to database detch name n age n show it on ui. 

  pseudo code for the same :

  try{
    // establish connection with database
  }
  catch{
    // run this code incase name n age was not present in badatabse
  } 
  finally{ 
    // runany clean up code in this example it can be closing the connection with database 

  }

  used to handle errors. 
  
  how to error by our own ?
    const sum = (a,b){
      return a+b;

    }

  i want to THROW error if sum is more than 10?

  concept of rethrow :
    we write catch block to handle errors coming from its try block...
    but thwn we errors in,pictily fromry block...
    we want to only catch certain kind of error.

    eg :
      in above example inside catch block only handle error which is of type 
      "referenceError"..apart from that is any other error happens, then, er-throw error 
      from catch block...
      
  errors like : 
    syntax errorr 
    referenceError

_______________________________________________________________________

 Curying :

_______________________________________________________________________

Async Javascript :


  timers and Intervals :-

  quetions:
    Create a timer i.r 
    create 2 buttons  - start and stop 
    on click of start , timer start with value 1 and on every 1 sec 
    it should be increment value by 1..
    on click of stop  timer will be stop  

  1. setInterval 
  2. clearInterval

  3. setTimeout
  4. Cleartimeout

  
_______________________________________________________________________

 
 BOM : 
 (browser object model)

  DOM   : (docment object model) : use to interact with html is the form of js object 
  (hierarchical manner)...

  Now, there is a way via which we can talk to broswer. (here, entitiy is browser 
  not document~html page)

BOM consists of js like :

1. alert
2. Prompt
3. confirm
4. location
5. navigator
6. history
7. screen

now, all these objects are part of window object.
in window object there is something called "document"...via basically 
enable DOM 

alert :

it is used to Alert use aboyt something
whenever alert method is called at that point...rest of the javascript
execution stops...
only after acknowledgement of Alert ...js execution begins again..
it returns undefined

--------------------------------

Prompt :

  give us option to write some message and also ability to answere to it..
  it ok is pressed...input answere is returned otherwise on cancle click..
  null is returned..
  execution of js stops..Null OK or CANCLE is pressed/

-------------------------------

confirm : 
  asts as a confirmmation box...if clicked on OK it returns true and if clicked on 
  cancle it retrurns false.

-------------------------------

Location :

can be used to access browser URL i.e location mentioned inside browser address 
bar.
  http://127.0.0.1:5500/_%20frontend-development-/javascript%20notes/BOM/bom.html

location.search -> 
  return path (in string form) query params..
  eg: URL -> http://127.0.0.1:5500/_%20frontend-development-/javascript%20notes/BOM/bom.html?id=125&Name=sharad
  location.search -> 'id=125&Name=sharad'

  Now to read above data we need to perform multiple transformation on string 
  Rather than doing that. we can make use of URLsearchparams

_______________________________________________________________________

Currying :

Design a function that adds 2 values.

function add(value1, value2){
  retrurns value1 + value2
}

DEsign a function that add a value but  always with 4;

function add(value4){
  return value +4;
}

Design unlimited funciton with above problem i.eachgenerate funtion that can add any number...

immediately it appears to be a problem of factory functio....

funtion generate(valuetobe){
  return funciton (actually){
    return valuetobe + actualvalue;
  }
}

const addby2 = generator(2);

addby2(20)// 22
-> generator(2)(20)//22


addby2(30) // 32
-> generator(2)(30) // 32


const addby4 = generator(
  4);

addby4(20); // 24
-> generator(4)(30) // 34

addby4(30); // 34
-> addby(4)(30) // 34

In above scenario, internally we are sing closures 
but same problem can be solved with .bind method also.


multiple(1)(2)(3)(4)............(n);

multiply(1)(2) -> 2

multiple(1)(2)(3) -> 6

multiple(1)(2)(3)(4) -> 24

_______________________________________________________________________

memoization ->

  function memo(factoryNAMe){

    // does large calculation which take 2 seconds

  } 

  Now,
  everytime if we call memo() it will take seconds everytime.
  Better approach can be if memo() is called with same input value then just return
  same output which was given before without calculating again.

function func(name){
  return  `${name} Trikha` // Assume it takes 2 seconds to do this
}

   let storeresults = {};
  funciton memo(factoryNAMe){

    const result = func(factoryNAMe);
    storeresults[factoryNAMe] = result;

    return result;
  }
_______________________________________________________________________

multiply(1,2) => 2 (2*1);
multiply(2,3) => 6 (2*6);

multiply(1)(2) => 2 (2*1);

_______________________________________________________________________

generators :
  function in which we stop/resume their execution.

  generator function returns object having several properties.

  1. next() => whenever we call next() method...exercise of code written
  inside generator function starts.......
  execution of code can stop if yield keyword is written in between...

  As soon as tield keyword is encountered..exeution stops and there is a value 
  given as output.. this value is given via yield keyword.

  next() method returns object having 2 properties :
    1. value
    2. done

    here value property holds value given via yield keyword.