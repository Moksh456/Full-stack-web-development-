LIVE SERVER : 
        HTTP://127.0.01/  =  HTTP://LOCAL HOST

        LOCAL HOST -> 127.0.0.1

        HTTP://127.0.0.1/INDEX.HTML

        PROTOCOL://IP_ADDRESS:PORT/INDEX.HTML

________________________________________________________________________________

j.s is very flexible because it will automatic detect which datatype is prefect for the

JAVASCRIPT :
    
    JAVASCRIPT FEATURES ->
     1. SINGLE THREADED
     2. PROTOTYPE BASED
     3. DYNAMIC
     4. INTERPRETED 
     
    MULTIPARADIGM =>

     1. EVENT DRIVEN -> J.S REACT TO EVENT (MOSTLY USER ACTION LIKE SUBMIT BUTTON)
     2. FUNCTIONAL -> PURE FUNCTION/FUNCTION TREATED AS FIRST CLASS.
     3. OBJECT ORIENTED PROGRAMMING LANGUAGE 
     4. IMPERATIVE
     5. DECLARATION
 
________________________________________________________________________________

JS.VARIABLE => 
     1. DECLARE A VARIABLE
     2. ASSIGN/DEFINE A VARIABLE
     3. USED THAT VARIABLE
     
     1. VAR <VARIABLE_NAME>  {JAVASCRIPT WAS ABLE TO DETECT THE VALUE BY IT NATURE OF THE VALUE THAT'S WHY JAVASCRIPT IS DYNAMIC LANGUAGE}
     2. <VARIABLE NAME> = VALUE;
     3. <VARIABLE NAME>

________________________________________________________________________________

VARIABLE NAME CAN START WITH $,_,AND ALPHABETS AND OTHER NUMBER ARE ALSO ALLOWED ALSO THE ARE.

________________________________________________________________________________

PRIMITIVE DATA TYPE ->
  1. STRING
  2. NUMBER
  3. BOOLEAN
  4. BIGINT
  5. NULL
  6. UNDEFINED 
  7. SYMBOL

  null => is a value that can be ASSIGNed  TYPE OF NULL IS NOT EQUAL TO "NULL" ROTATE IT IS AN "OBJECT" -> IT WAS A BUG THAT GOT INTRODUCED IN J.S INTRODUCED IN JS IN 1990ss

  UNDEFINED -> if we have not assigned any value to variable any value to the variable by the default value is given as undefined and also type of that variable result in "undefined" 
  i.e   VALUE OF DATATYPE BOTH APPEAR TO BE THE SAME.

________________________________________________________________________________

NOT PRIMITIVE DATATYPE :
        1. OBJECT =>
          IS A ENTITY HAVING STATE N BEHAVIOR 

          *=> using object literal->

          VAR OBJECT = {
            KEY: "VALUE"
            KEY: "VALUE"
          }

          VAR PERSON = {
            NAME: "SHARED";
            NAME: 28;
            IS_IIT: FALSE;
            EDUCATION:{
                HIESEC: "PASS";
                B.TECH: "PASS";
            }
          }


          using new KEYword -->
            var person = new object();
            person.name = "SHARED"
            person.age = 25
            person.iition = FALSE
            person.EDUCATION{
            
            }

________________________________________________________________________________

Arrays =>
   declare/DEFINE Arrays

   var x = []; -> declare variable with name "x" and assign it this empty array.
   initialize array with value -> 1,2,3,4.

   eg. var y = [1,1,1,2];

   access value in an array 
   y[0] y[1]


   Que. can we sore different primitive data type in an array?
   var arr  = [1,"rohit",false, 25n];
   ans. yes this happen 

  using new keyword
    var arr = new array ();
    var arr = new array (1,2,3,); -> for declare value in Arrays
    var arr = new array (10); -> declare the length of array.

for (var a = 0; a>arr; a++){
  console.log()
}



________________________________________________________________________________

FUNCTION => 
      syntax -> 
       function fun_name(){
        function reusable code of and set of insertion to ne executed
       }

       eg. function sum(a,b){
        return a+b
       }


________________________________________________________________________________

function sum (a,b){
  var sum = a+b;

  return function dummy (){
    console.log("I am a dummy");
  }
}

arrays are internally store as a object in j.S

________________________________________________________________________________

type of a function (){}
      => function

functin sumof(a,b){
  var sum a+b;

  var dummy = function sharad(){
    console.log("i am a dummy");
  }

  return dummy;
}
var result = sumof(50,30);
console.log(result());

________________________________________________________________________________
J.S operators :- /,+,*,-
 operands ->   2(operands)  +(operator)  3(operands)


operands -> op1 operator op2 (binary operator)

op1 operator -> eg a++ (unary operator)

________________________________________________________________________________
arithmetic = 
      +,-,*,/,%,++,-- .......etc.

        10 + "20"   = 1020
        "10" + "20" = 1020
        10 + true   = 11
        10 + false  = 10
        10 + " "    = 10
        10 + null   = 10
        10 + undefined = NAN

number + string  -> 
  choice1 = convert both into a to number 

  choice2 = convert both in String.

  but one rule remains some -> 
  i.e both type should should be same.

  they gone with option2 -> ie 10 + "20" internally convert to =
   => "10" + "20" -> finally 2string concat (+) -> "1020"

________________________________________________________________________________

number + true 

  number + boolean ->
  but one rule remain same -> i.e bothtype should be same 

  number + boolean ->
   choice 1 = both convert into a boolean = b + B
   choice 2 = both convert into a number = n+N

   "a" + "b" = NAN

________________________________________________________________________________

comparison operators -> 
 <,>,<=,>=,==,===

 20 == 20     = true
 20 == "20"   = true
 20 === 20    = true
 20 === "20"  = false

 == only check the value
 === check the value and also check the value both.

________________________________________________________________________________

short overview of (DOM):- 
                          DOM(Document, object, Model)

  browser = lets represent html Document in the form of object.

  j.s -> DOM ->

  js file    -> Dom -> html

Document.queryselector("h1");

var element = document.queryselector("h1");

element = h1

element.innertext = h1 value

for select id in js file  -> docment.queryselector(#id name);

________________________________________________________________________________

logical operators =>
      (and)&&, ||(or), !(not)

      A && B  
        if a -> false will B Be evaluted 
        ans: no

        if a is true then B is evalated true (yes) 
      var a =  true && "sha" 
      ans: sha

      var a =   true && true
      ans: true
      
      var a = false && true
       ans: false
  if left operands is truen then return right operands.

  here left operand neet to be type of boolean and if it is not then implicity javascript will convert is to boolean () constructor.

||(or) =>
      is left operands is true then return left return

!(not)=>
 it is used for not.

________________________________________________________________________________

Assigment operators = 

=, +=, -=, *=, /=, %/ **=

________________________________________________________________________________

bitwise operator => 
  not imp for web dev but very imp for dsa.

  var a = 3 +  2 *  5  = 13
  var a = (3+2) * 5    = 25
________________________________________________________________________________

  precedence & associativity:
  each operators in an lang have it own associativity there are 2 type left associative && right associative.

  operators ->
    (=) -> either flow will be from left to right or from right to left.


________________________________________________________________________________

var a = 3 + 2 * 3;
first check operators who have highest precedence then executive them according to their associativity then again repeat return 1
________________________________________________________________________________

scope ->
 local vs global

  local scope->
  if any variable is defined inside function then that varuable can only be accessed inside that function 

  global Scope ->
  if any variable is defined globally them it is accessible to every function.
________________________________________________________________________________

function ->
syntax 1 :
function DECLARATION
funciton <function name>(){

} 

syntax 2 -> 
function expression


2.1 -> named function
var <variable_name> = function<function_name>(){
.......
}

2.2 ->
anonymous function

var <variable_name> = function(){
......
......
........
Runtime error
.....
......
........
}


 syntax 3->
Ife (immediately invoked function expression)


 function my(){
  var sum = 2+3;
  return sum
 }
 my();

requiraments->
 -> i want to be function be execute immediately but also it should execute only once 


syntax: 
{
  function (){
    ......
  }
}();


4. Arrow function (Es6) - tbd  (to be discussed)

 
________________________________________________________________________________

How j.s works?
j.s is SINGLE THREADED , it is also synchromous ->

that means only 1 statement can execute at a time.

Execution context :
Whenever js script is INTERPRETED, execution is created context is created for each function invocation.

by default there is global execution context created Whenever our code is executed. 

Execution context is made of 2 phases :
  1. memory 
  2. execution

  1. Memory creation :
  Memory is allocated to each object and function (internally function are also object ) 

  eg:
  function sum(){
    var result = 10 + 20;
    console.log(result);
    return result;
  }

  var name = "sharad";

  here, sum and name needs to be allocated memory.

  once memory is allocated js will assign value to these.

  for variable default value is undefined.

  for function default value is -> whole funciton body is copy/pasted.

  2. execution phases: 
  

________________________________________________________________________________

by value vs  by reference :
in js object & arays (basically object only) are reference while peimitive (number, boolean,String etc ) are treated as value

int arr []

________________________________________________________________________________
hoisting ->
  ability to access variable and function even before   declaration internally there is no magic this is how js execution context work and  due to which this kind of phenomena.

________________________________________________________________________________

ES6 variable construct : (es6 ~ es2015  ~ feature intruduced in 2015 in javascript)
{  let,   const  }


both keyword are used for declaration.

let -> 
    1.   var title = "moksh"

       v/S
    2.   let title = "moksh"

  both are different with respect to scope 
  
  var is function scoped and let let is block.

  function scope: 
            any thing defined inside function key word will be visible in that function only.


  Block Scoped =>
            any thing defined inside block i.e opening block { and closing block } it will be visible inside these bracket.
            it will inside in the opening and closing bracket.



const -> it BEHAVIOR same as let only diff being it cannot be reassigned.

 
________________________________________________________________________________

var =>  declare with var hoisted it can be accessed before declaration.

let,const => variable with var are not hoisted but in reality js work the same 
(i.e execution context memory allocation please happen for these variables also 
that mean memory is allocated to these variable also that mean memory is 
allocated to these variable to but they still can not be accessed due to temporary zone  )

________________________________________________________________________________
 loops =>
      1. while loop 
      2. do while
      3. for
      4. switch case 
      5. if else 
      6. else.if....if..else
      7. break continue 

________________________________________________________________________________

parse Int /  Parse Float =>
                    parse int ("saved25 ) -> NAN

                    i.e only when digit are present in the being it is able to extract. 

    parse Float ->
              same rules as parsing change to float.

________________________________________________________________________________
 object's :->
            var obj = {
              key: value
            }

            or 

            const obj ={
              KEY: value
            }

            or

            let obj ={
              key:value
            }

            here key can be String or symbol where as value can be anything also key needs to be unique also.

            let obj ={
              title : "moksh",
              age : 25,
              }


            how to access => 
            1. Dot notation 
            2. bracket notation

            obj["title" ]


            let object ={
              title : "moksh",
              age : 28;
              "this is age" : "lol"
            }

for access this is age we use bracket notation

obj["this is age"]

bracket preferd/only option the 

this is space between keyword.

when we want access some value of object with dynamic key'S

--------
obj delete ['age']

delete ant property of object 
delete<object_name> [keyword]

________________________________________________________________________________

{} === {}

________________________________________________________________________________

shorthand: 
      let title = "sharad";

        let obj ={
          title: title,

        }

        or

        let title = "shara";

        let obj ={
          title
        }

        or

        let person = {
          name: sharad,
          age: 28,
        }

        
        let person = {
          name: sharad,
          age: 28,
        }

        
        let person = {
          name: sharad,
          age: 28,
        }
j.s is not close base lan

function person (name, age){
  
}

let person1 = ("sharad", 28);
------------

function person (name, age){
  this.name = name;
  this.age = age;
}

let person1 = new person("sharad", 28);

here new -> create new object and assign that newly related object to this variable and it return newly created object.


this -> it is act as a place holder variable name for this newly created  object.

new => 
      created object -> {}
      point "this" to newly created object.

      this ={};

      return newly created object.

    whenever inside the function we want to fill certain details in the newly 
    created object we can use "this" keyword for that. 

________________________________________________________________________________
"this" is nothing it is the empty object
________________________________________________________________________________

making object using constructor 
function person(name, age){
  this.name = name;
  this.age = age;
}

let person1 = new person ("sharad", 28);
console.log(person1)

this keyword point to some entity on js(generally it will point window object )creating object via function constructor this  point to newly created object.

________________________________________________________________________________

SYMBOL: =>
            primitive type 
            used to generate new value 

            Syntax: 
                    symbol(<name_declare);

even if name description is same then also symbol constructor will return different/ unique symbol VALUE
________________________________________________________________________________

symbol ("sharad" ) -> return symbol value or symbol (which is always unique)

usecase:
     primarly sued as a key of object since key always be unique hence creating keys of object with symbol instead of String will help avoid key duplication.

Note:+++++++++++
    in order to avoid uniqueness we can use symbol for()

--------------------------------------------------------
eg. 
    let symbol = symbol.for("title);
    let symbol2 = symbol.for("title");

    symbol === symbol2 
    => true

i.e if description is same then symbol value should also be the same.


object:
  
  In keyword:
      <keyname> in <object_name>

  has own property keyword:
      <keyname>.hasOwnProperty<object_name>

________________________________________________________________________________

Methods: 


      let obj = {
        title: "sharad",
        age: 28,
        
        showtitle : function(){
          console.log("hey i am a function");
        }
      }



getters & setters :
          any method inside object can be termed as a getter or setter via keyword "get" and "set"

while calling getters/setters methods, () should not be used.

let person ={
  title: "sharad",

  get gettitle(){
    //can do anything bu generally used to fetch object properties
    return this.title;
  }

  set settitle(name){
    this.title = name;
  }
}
person.settitle = "ankit";
________________________________________________________________________________

loops :
        1. for

        2. while

        3. do.while


   1.    
   (i)  for...in ->

            let obj ={
              title: "sharad",
              age: 28;
              isNew: false 

            }
            for(let element in obj){
              console.log(element);
            }



      it is trying to itterate over obj object and on each iteration there is a variable called element which is filled with keyname.

________________________________________________________________________________

Dom (document object model):
interface/bridge between js and html/css 

whole document (ie html page ) represent in the form of js object

object is available globally and named as "document" it is a part of global window object also (window.document).

now,
 any js object consists of properties and method.

 under document object we will use certaing methods to interact with out html page. 

1. getElementById -> input is Id name -> output is html element is found and null if id will not found by the js selector.

2. getElementByClass -> input is Class_name -> output is htmlCollectionOf<element>  (arrays of element but not completely true)

3. getElementByTAgName -> input is tag_name -> output is -> htmlCollectionOf<element>   (arrays of element but not completely true)


4. queryselector -> input is css_selector -> output is -> Element or null

not : query selector always return signle element if more than one element matchesm, then element tag comes first will be returned by this method (top to bottom manner)

5. queryselectorAll -> input is css_selector -> output is nodelistof<element> or null


all the above element of document are for ->
to get hold of particular html element.
this is similar to css selector where we used to catch hold of particular html element.

eg: Id selector(#ID), class selector(.class_name);

________________________________________________________________________________

split is very imp interview que
________________________________________________________________________________

how to add and create html element via js add to html page?

document.createElement("div");
 
 const element = document.createElement("div");
 element.innertext = "h1 Created via js";


 how to attach to html page?

 document.body.appendChild(element);

________________________________________________________________________________

script tag ->
 
        defer vs async

defer suits in situations -> where js file is intereacting with DOM
async suits in situations -> where js file is intereacting with with Dom

initially
In Defer there is a guarantee of order of execution whereas in async there is
no guarantee

________________________________________________________________________________

transform: "translate(x,x) Scale() rotate()"
________________________________________________________________________________

note:
if value undefined given, then it will treated as string "undefined"
if value null given then, it will be treated as a empty value
if value "" given  then it will treated as a "" value

________________________________________________________________________________

function beautifuname(name, prefix = "lord", decorate){
    if(decorate){
        return decorate(name)
    }
    return `${prefix } $ {name}`
}

const v1 = beautifuname("sharad");
const  v2 =  beautifuname("sharad", "newton -")

const decorfunc = function(name){
    return  ` $ {name} name is going to enjoy week`
}

const v3 = beautifuname("sharad", "" , decorfunc);

here line no. 807 we are passing function and we are allowed to do so in javascript since functions are treated as first class citizens in js i.e function should be treated as a normal value/variable like boolean object array number etc. that mean function can be passed as input to any other function also it can be returned i.e can be returned i.e function can return function here decorfunc can be called as "cal back function"
why? because decorfunc is not called directly rather it is being called by other function

Note: in above usecase, actual power of callback funcation is not visible it is primarly used for async

console.log(v1)// lord sharad
console.log(v2) // newton - sharand
console.log(v3) // sharad

________________________________________________________________________________

document.querySelector(".grandparent").addEventListener("click", function(){
    console.log("Grandparent clicked");
 
}, true);
document.querySelector(".parent").addEventListener("click", function(){
        console.log("Parent clicked");  
},  true)
document.querySelector(".box2").addEventListener("click", function(){
    console.log("Box 2 clicked"); 
}, true)
document.querySelector(".box1").addEventListener("click", function(){
console.log("Box 1 clicked"); 
}, true);

   whenever child is cliked (OR basically any event is fired ),
   then only callback function of child div should be ivoked?

   or

   all the html element (who are in hiererchy w.r.t child div) ->
   for these html elements onclick callbackj function should be run (only for when callback functoin is registered on them via addEventListener ).

   second approach got finalized.
   Now  quetion was ->
   Now to implement the flow?

   i.r->
   Whether function of child should be called first then  
   callback function of parent should be called,
   callback function of grand parent should be called 

   or (oppsite flow)

  Whether function of child should be called first, then,  
   callback function of parent should be called,
   callback function of grand parent should be called 

  -->

  it was decided that lets keep both the flows.
  first  flow was named as -> BUBLE
  second flow was named as -> CAPTURE

  Event Bubble -> 
  Bubble means it goes up (i.e from where it happend till last html element)

  Event Capture ->
  capture meant it goes down (i.r from first htm element w.r.t hirerachy till the point where it happened )

  by default Event Bubble technique is applied
   In order to change the stragety to capture ->
   we use supply third argument to add event listner methnod methnod as true

   Now we want to conclude How events are actually traversing across DOM:
   
   we need to remember that flow always goes form top to targer first.
   then, it travarses back from target to Top.

   i.e each DOM element is given 2 chances to execute their callback funciton either during capture phases or During bubble please.
   
  in case we want to stop propgation of events we can use stopProgpogation() methnod of event object.


thumb rule is  if possible to keep event listener callback to Minimum.


________________________________________________________________________________
 Call, bind, apply

if we want to change CONTEXT of THIS variable inside methods we  can do that with the help of method called - call(), apply(), Bind().

let obj = {
  name: "sharad",
  age: 28,
  printname function(){
    console.log(obj.name);
  }
}

here this points to obj object
Now we want "this" to point towards some other object.

eg.
let obj2 = {
  name: "trikajh"

} 

Basically we want "this" inside printname method of obj2 to point to "obj2" rather than "obj". 

obj.pritname() -> this will point to obj.
but i want to perform some magic that it should be start pointing to obj2

basically we want to change CONTEXT of this i.e we want to change - where this is pointing to ?

to do that there are 3 type

call ->
<function>.call(<variable_that_you_want_this_to_point_towards>, <input1> , <input2>)


apply ->
<function>.apply(<variable_that_you_want_this_to_point_towards>[<input1>, input2])


in case of apply second arguments is array form

bind ->
  bind is also changes context of this but its different from call and apply in the sense that incase of bind function is not good executed immediately.

  bind method -> returns a function with context of "this"

    <function>.bind(<variable_that_you_want_this_to_point_towards>)

    bind method returns new function with new context of "this"
    i.e we can call the function at a later stage whenever it is required.


 1. by the help of call method:
 
         obj.printname.call(obj);



 2. by the help of apply() method 
 
          obj.printname.call(obj);

  2. by the help of  bind() method
           obj.printname.bind(obj);

________________________________________________________________________________